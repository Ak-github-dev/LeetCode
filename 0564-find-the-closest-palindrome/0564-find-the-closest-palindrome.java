/*
Approach:

Understand the Problem:

You need to find the closest palindrome to the given number n.
If there is a tie (two palindromes at the same distance), return the smaller one.
Special cases include when n is a single-digit number or the smallest possible number like "1".

Generate Candidate Palindromes:

Generate possible palindrome candidates around the number n by manipulating the first half of n.

Consider the following cases:
Palindrome generated by mirroring the first half of n.
Palindrome generated by increasing the first half by 1 and then mirroring it.
Palindrome generated by decreasing the first half by 1 and then mirroring it.
Handle edge cases like "100...001" and "99...999".

Calculate the Closest Palindrome:

For each candidate, calculate the absolute difference from n.
Track the closest palindrome, considering ties by choosing the smaller one.
*/
class Solution {
    public String nearestPalindromic(String n) {
        long num = Long.parseLong(n);
        int len = n.length();
        
        // Candidate palindromes
        Set<Long> candidates = new HashSet<>();
        candidates.add((long) Math.pow(10, len - 1) - 1); // Lower edge case: 999...999
        candidates.add((long) Math.pow(10, len) + 1); // Higher edge case: 100...001
        
        long prefix = Long.parseLong(n.substring(0, (len + 1) / 2));
        
        for (long i = -1; i <= 1; i++) {
            String candidate = createPalindrome(prefix + i, len % 2 == 0);
            candidates.add(Long.parseLong(candidate));
        }
        
        candidates.remove(num); // Exclude the number itself
        
        long closest = -1;
        for (long candidate : candidates) {
            if (closest == -1 ||
                Math.abs(candidate - num) < Math.abs(closest - num) ||
                (Math.abs(candidate - num) == Math.abs(closest - num) && candidate < closest)) {
                closest = candidate;
            }
        }
        
        return String.valueOf(closest);
    }
    
    private String createPalindrome(long prefix, boolean evenLength) {
        String strPrefix = String.valueOf(prefix);
        StringBuilder sb = new StringBuilder(strPrefix);
        if (!evenLength) {
            sb.deleteCharAt(sb.length() - 1);
        }
        return strPrefix + sb.reverse().toString();
    }
}